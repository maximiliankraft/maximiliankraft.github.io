<!DOCTYPE html>
<html>
<head>
<title>README.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="deployment">Deployment</h1>
<p>Ziel dieser Aufgabe ist des das CRUD-Assignment in eine einizge Docker-Compose Datei zu packen um diese von überall aus ausführbar zu machen (deployment). Damit wäre es im weiteren auch möglich diese Datei auf einer Azure-Instanz o.ä hochzuladen und von dort aus auszuführen. Auch Interessant ist diese Art des Deployments für IT-Abteilungen von Firmen mit denen man zusammenarbeitet. Die freuen sich meistens wenn man Ihnen durch so etwas die Arbeit etwas abnimmt und man ist bei Updates nicht auf sie angewiesen, vorausgesetzt es wird immerwieder die neueste Version aus dem Registry gepullt (<code>docker pull &lt;imagename&gt;</code>).</p>
<p>Dazu braucht es folgende Voraussetzungen:</p>
<ul>
<li>Dockerfiles</li>
<li>Images</li>
<li>Container-Registry</li>
<li>CI/CD Pipelines</li>
<li>Je ein Repository für Frontend und Backend (bereits exisiterende können ggf. weiterverwendet werden)</li>
</ul>
<p>Füge (falls nicht schon vorhanden) sowohl im Frontend als auch im Backend ein Dockerfile hinzu. Im übergeordneten Ordner kann sobald beide Dateien Images builden ein docker-compose mit folgender Struktur angelegt werden:</p>
<pre class="hljs"><code><div><span class="hljs-attr">version:</span> <span class="hljs-string">"xy"</span>

<span class="hljs-attr">services:</span> 
   <span class="hljs-attr">frontend:</span>
       <span class="hljs-attr">build:</span> <span class="hljs-string">./frontend</span>
   <span class="hljs-attr">backend:</span>
       <span class="hljs-attr">build:</span> <span class="hljs-string">./backend</span>
</div></code></pre>
<p>Das ist schon ein guter Start, jedoch setzt dieses Dockerfile voraus das der Programmcode in den Unterordnern vorliegt. Für einen Entwickler ist das kein Problem, aber wenn man das Programm dann beim Auftraggeber installieren möchte, möchte man dem im Normalfall nicht den Code geben. Deswegen ist es besser wenn man die Images in einer <code>Container-Registry</code> hochlädt um von überall aus auf diese zugreifen zu können. Dann schaut das Compose ca. so aus:</p>
<pre class="hljs"><code><div><span class="hljs-attr">version:</span> <span class="hljs-string">"xy"</span>

<span class="hljs-attr">services:</span>
   <span class="hljs-attr">frontend:</span>
       <span class="hljs-attr">image:</span> <span class="hljs-string">ghcr.io/&lt;username&gt;/&lt;CRUD_frontend_imagename&gt;</span>
   
   <span class="hljs-attr">backend:</span>
       <span class="hljs-attr">image:</span> <span class="hljs-string">ghcr.io/&lt;username&gt;/&lt;CRUD_backend_imagename&gt;</span>

</div></code></pre>
<h2 id="aufbau-des-image-feldes">Aufbau des Image-Feldes</h2>
<ul>
<li>ghcr.io Github container registry</li>
<li><username> Dein Username auf Github</li>
<li><imagename> Der Name des Images der beim CI/CD wird meistens über einen Tag in Git festgelegt</li>
</ul>
<p>Zum Vergleich: Ein Image weit verbreiteter Software sieht oft so aus <code>mysql</code>. Dabei wurden für einige der obigen Felder Standardannahmen getroffen. In voller Länge würde es so aussehen: <code>docker.io/libraries/mysql:latest</code>. Alles bis auf <code>mysql</code> sind Standardparameter.</p>
<h2 id="einrichten-der-cicd">Einrichten der CI/CD</h2>
<p>Die Containerimages kann man entweder Lokal builden und ins Registry hochladen oder sich auf den Github-Servern bauen lassen.  Bei den Github-Servern ist der Vorteil dass man sicherstellen kann das vor dem Buildprozess Unittests, Sicherheitschecks etc. durchgeführt werden.</p>
<p>Um die Github Server anzuweisen ist folgende Ordnerstruktur im Repository zu erstellen: <code>.github/workflows/&lt;docker_build_actionname.yml&gt;</code></p>
<p>Die Datei könnte ca. so aussehen:</p>
<pre class="hljs"><code><div>
<span class="hljs-attr">name:</span> <span class="hljs-string">Create</span> <span class="hljs-string">and</span> <span class="hljs-string">Push</span> <span class="hljs-string">a</span> <span class="hljs-string">Dockerfile</span> <span class="hljs-string">inte</span> <span class="hljs-string">the</span> <span class="hljs-string">registry</span>

<span class="hljs-attr">on:</span>
  <span class="hljs-attr">push:</span>
    <span class="hljs-attr">tags:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">'*'</span> <span class="hljs-comment"># jobs ausführen wenn ein git tag gepusht wird</span>
      <span class="hljs-comment"># branches: [ main ] # jobs ausführen wenn etwas auf den main branch gepusht wird</span>

<span class="hljs-attr">permissions:</span>
  <span class="hljs-attr">contents:</span> <span class="hljs-string">write</span>

<span class="hljs-attr">jobs:</span>
  <span class="hljs-attr">build:</span>
    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span>

    <span class="hljs-attr">steps:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span> <span class="hljs-comment"># schritt eins repo am server klonen</span>

    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span> <span class="hljs-string">with</span> <span class="hljs-string">kaniko</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">...</span> <span class="hljs-comment"># mit kaniko (o.ä) das dockerfile bauen und dann ins repository hochladen</span>


    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Release</span> <span class="hljs-string">with</span> <span class="hljs-string">Notes</span> <span class="hljs-comment"># freiwilliges extra, release im repo erzeugen</span>
      <span class="hljs-attr">uses:</span> <span class="hljs-string">softprops/action-gh-release@v1</span>
      <span class="hljs-attr">with:</span>
        <span class="hljs-comment"># todo .. pfad zur jar-datei gezippter dist ordner etc. </span>
      <span class="hljs-attr">env:</span>
        <span class="hljs-attr">GITHUB_TOKEN:</span> <span class="hljs-string">${{</span> <span class="hljs-string">secrets.GITHUB_TOKEN</span> <span class="hljs-string">}}</span>
</div></code></pre>
<blockquote>
<p>Anleitung zum Containerimages bauen mit Kaniko: https://cloud.google.com/build/docs/optimize-builds/kaniko-cache?hl=de</p>
</blockquote>
<h2 id="bewertungsgrundlagen-bei-der-abgabe">Bewertungsgrundlagen bei der Abgabe</h2>
<p>Füge jene docker-compose.yml Datei in das Repository der aktuellen Abgabe hinzu welche auf die von dir erstellten Images verweist.</p>
<p><em>Abzugeben ist</em>:</p>
<ul>
<li>eine Docker-Compose Datei mit Images</li>
<li>ggf. Logindaten um Zugriff auf die Lokalen Container zu erhalten
<ul>
<li>NICHT das eigene Passwort sondern nur einen Zugangstoken für die Registries</li>
</ul>
</li>
</ul>
<p><em>Punkteverteilung</em></p>
<ul>
<li>Nach einem Docker-Login von meiner Seite mit eurem Token kann ich die Images pullen 25P</li>
<li>Die Images können ausgeführt werden ohne sofort abzustürzen 25P</li>
<li>Bei den Tags gibt es sowohl eine aktuelle Version vX.Y als auch einen <code>latest</code>-Tag für die neueste Version 25P</li>
<li>Beim Build eines neuen Images gibt es eine Schritt (Step) für das Ausführen von Unittests 25P</li>
</ul>

</body>
</html>
